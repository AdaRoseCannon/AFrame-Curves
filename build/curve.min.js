!function(){"use strict";!function(){const t=new THREE.Vector3,e=new THREE.Vector3,i=new THREE.Vector3,n=new THREE.Vector3,s=new THREE.Vector3,o=new THREE.Matrix4,r=new THREE.Quaternion,c=new THREE.Vector3(0,0,0),a=new THREE.Vector3(0,0,1);AFRAME.registerComponent("curve",{description:"This defines a catmull rom spline curve. It is exposed on el.components.curve.curve, ",schema:{tension:{default:.25},closed:{description:"Whether it joins back up with it's tail",default:!1}},init(){this.onPointShift=this.onPointShift.bind(this),this.onChildRemove=this.onChildRemove.bind(this),this.update=this.update.bind(this),this.el.addEventListener("point-shift",this.onPointShift),this.el.addEventListener("point-change",this.update),this.observer=new MutationObserver(this.onChildRemove),this.observer.observe(this.el,{subtree:!0,childList:!0}),this.points=new Map},onChildRemove(t){const e=Array.from(this.points.keys());for(const i of t)for(const t of i.removedNodes)e.includes(t)&&(this.needsUpdate=!0)},onPointShift(){this.curve&&(this.handlePointParents(),this.curve.updateArcLengths(),this.el.emit("curve-shift"))},update:function(){this.needsUpdate=!0},handlePointParents(){let t;for(const[e,i]of this.points){const n=e.object3D;i.copy(n.position),t=!1,n.traverseAncestors((e=>{e===this.el.object3D&&(t=!0),t||i.applyMatrix4(e.matrix)}))}},tick(){if(this.needsUpdate&&(this.needsUpdate=!1,this.points=new Map(Array.from(this.el.querySelectorAll("a-curve-point")).filter((t=>!!t.object3D)).map((t=>[t,new THREE.Vector3]))),this.handlePointParents(),!(this.points.size<=1))){this.curve=new THREE.CatmullRomCurve3(Array.from(this.points.values())),this.curve.closed=this.data.closed,this.curve.tension=this.data.tension,this.curve.arcLengthDivisions=Math.ceil(this.curve.getLength()/.01),this.curve.updateArcLengths(),this.ready=!0,this.el.emit("curve-updated");for(const[{object3D:i},n]of this.points){const{tangent:s,position:o}=this.closestPointInLocalSpace(n),r=s.multiplyScalar(.4).add(o),c=e.copy(r);d(o,t.set(0,1,0).applyQuaternion(i.quaternion),r,c),i.lookAt(c)}}},remove(){this.curve=null,this.ready=!1,this.observer.disconnect()},closestPointInLocalSpace(e,o){const r=this;if(!this.ready)throw Error("Curve not instantiated yet.");o=o||.1/this.curve.getLength();const c=[];for(let t=0;t<=20;t++){const i=t/20%1,s=this.curve.getPointAt(i,n),o=e.distanceTo(s);c.push(o)}const a=c.reduce(((t,e)=>t<e?t:e));return function c(a,h){const d=(1+a+h)%1,l=(1+a-h)%1,v=r.curve.getPointAt(d,n),p=r.curve.getPointAt(l,s),f=v.distanceTo(e),m=p.distanceTo(e),E=f<m;if(h<o){const e=r.curve.getTangentAt(E?d:l,i);if(h<o)return{result:E?d:l,position:E?v:p,distance:E?f:m,normal:u(e,t),tangent:e}}return c(f<m?d:l,h/2)}(c.indexOf(a)/20,.05)}}),AFRAME.registerComponent("curve-point",{description:"A point that tracks itself in 3D world space and updates the curve that it has changed.",dependencies:["position"],schema:{},init:function(){let t=this.el;for(;t&&t.matches&&!t.matches("a-curve,[curve]");)t=t.parentNode;if(!t)throw Error("curve-points need to be inside a curve");this.parentCurve=t,this.oldPos=new THREE.Vector3},update:function(){this.el.emit("point-change")},tick(){const t=this.el.object3D.getWorldPosition(n);0!==this.oldPos.manhattanDistanceTo(t)&&this.el.emit("point-shift"),this.oldPos.copy(t)},remove:function(){this.el.emit("point-change")}});const h=new THREE.Quaternion;function u(t,e){e.set(0,1,0);const i=e;return h.setFromUnitVectors(a,t),i.applyQuaternion(h),i}function d(t,e,i,n){const s=(e.dot(t)-e.dot(i))/e.length();return n.copy(e),n.multiplyScalar(s),n.add(i),n}AFRAME.registerComponent("draw-curve",{dependencies:["curve","material"],schema:{curve:{type:"selector"},spacing:{default:.5},tangent:{default:!1},normal:{default:!1},length:{default:.1}},init:function(){this.el.addEventListener("curve-updated",this.update.bind(this))},update:function(){if(this.data.curve?this.curve=this.data.curve.components.curve:this.el.components.curve.curve&&(this.curve=this.el.components.curve),this.curve&&this.curve.curve){const e=this.curve.curve.getLength(),n=Math.ceil(e/this.data.spacing);let s,o,r;const c=new THREE.Line(new THREE.BufferGeometry,new THREE.LineBasicMaterial({color:"red"}));this.el.setObject3D("line",c);const a=this.curve.curve.getSpacedPoints(n);c.geometry.setFromPoints(a),this.data.tangent&&a.forEach(((e,r)=>{const a=r/n;s=t,s.copy(e),s.add(this.curve.curve.getTangentAt(a,i).normalize().multiplyScalar(this.data.length)),o=(new THREE.BufferGeometry).setFromPoints([e,s]),c.add(new THREE.Line(o,new THREE.LineBasicMaterial({color:"green"})))})),this.data.normal&&a.forEach(((e,o)=>{const a=o/n;s=u(this.curve.curve.getTangentAt(a,i),t).multiplyScalar(this.data.length),s.add(e),r=(new THREE.BufferGeometry).setFromPoints([e,s]),c.add(new THREE.Line(r,new THREE.LineBasicMaterial({color:"white"})))}))}},remove:function(){this.el.getObject3D("mesh").geometry=new THREE.Geometry}}),AFRAME.registerComponent("clone-along-curve",{dependencies:["curve"],schema:{curve:{type:"selector"},spacing:{default:1},scale:{type:"vec3",default:{x:1,y:1,z:1}}},init:function(){this.onPointShift=this.onPointShift.bind(this),this.update=this.update.bind(this),this.el.addEventListener("model-loaded",function(t){t.target===this.el&&this.update()}.bind(this)),this.pointShift=!0},update:function(){this.remove(),this.data.curve?(this.curveEl=this.data.curve,this.curve=this.data.curve.components.curve,this.curveEl.addEventListener("curve-shift",this.onPointShift),this.curveEl.addEventListener("curve-updated",this.update)):this.el.components.curve&&(this.curveEl=this.el,this.curve=this.el.components.curve,this.curveEl.addEventListener("curve-shift",this.onPointShift),this.curveEl.addEventListener("curve-updated",this.update))},onPointShift:function(){this.pointShift=!0;const t=this.el.getObject3D("clones");if(t){const e=t.children[0].instanceMatrix.count,i=this.curve.curve.getLength();Math.ceil(i/this.data.spacing)>Math.floor(1.05*e)&&this.update()}},tick(){const t=this.el.getObject3D("mesh");if(t){let e=this.el.getObject3D("clones");const s=this.curve.curve.getLength(),h=Math.ceil(s/this.data.spacing);if(!e&&this.curve&&(t.visible=!1,e=new THREE.Group,this.el.setObject3D("clones",e),t.traverse((function(t){if(t.geometry){const i=t.geometry.clone();i.applyMatrix4(t.matrix);const n=new THREE.InstancedMesh(i,t.material,h);n.instanceMatrix.setUsage(THREE.DynamicDrawUsage),e.add(n)}})),this.pointShift=!0),this.pointShift){const t=e.children[0].instanceMatrix.count;for(let s=0;s<t;s++)if(s>h){o.compose(c,r,c);for(const t of e.children)t.setMatrixAt(s,o)}else{const c=s/Math.min(h,t),u=this.curve.curve.getTangentAt(c,i);o.compose(this.curve.curve.getPointAt(c,n),r.setFromUnitVectors(a,u),this.data.scale);for(const t of e.children)t.setMatrixAt(s,o)}for(const t of e.children)t.instanceMatrix.needsUpdate=!0}}},remove:function(){this.curve=null;const t=this.el.getObject3D("clones");t&&(t.children.forEach((t=>t.dispose())),this.el.removeObject3D("clones"))}}),AFRAME.registerPrimitive("a-draw-curve",{defaultComponents:{"draw-curve":{}},mappings:{curve:"draw-curve.curve"}}),AFRAME.registerPrimitive("a-curve-point",{defaultComponents:{"curve-point":{}}}),AFRAME.registerPrimitive("a-curve",{defaultComponents:{curve:{}},mappings:{closed:"curve.closed",tension:"curve.tension"}})}()}();
//# sourceMappingURL=curve.min.js.map
