!function(){"use strict";!function(){const e=new THREE.Vector3,t=new THREE.Vector3,i=new THREE.Vector3,n=new THREE.Vector3,s=new THREE.Vector3,o=new THREE.Matrix4,r=new THREE.Quaternion,c=new THREE.Vector3(0,0,0),a=new THREE.Vector3(0,0,1);AFRAME.registerComponent("curve",{description:"This defines a Catmull-Rom spline curve. It is exposed on el.components.curve.curve, ",schema:{tension:{description:"[The Catmull-Rom Tension](https://www.w3.org/Graphics/SVG/WG/wiki/Path_Enhancements#:~:text=A%20Catmull%2DRom%20curve%20is,not%20through%2C%20the%20points%29)",default:.25},closed:{description:"Whether it joins back up with it's tail",default:!1}},init(){this.onPointShift=this.onPointShift.bind(this),this.onChildRemove=this.onChildRemove.bind(this),this.update=this.update.bind(this),this.el.addEventListener("point-shift",this.onPointShift),this.el.addEventListener("point-change",this.update),this.observer=new MutationObserver(this.onChildRemove),this.observer.observe(this.el,{subtree:!0,childList:!0}),this.points=new Map},onChildRemove(e){const t=Array.from(this.points.keys());for(const i of e)for(const e of i.removedNodes)t.includes(e)&&(this.needsUpdate=!0)},onPointShift(){this.curve&&(this.handlePointParents(),this.curve.updateArcLengths(),this.el.emit("curve-shift"))},update:function(){this.needsUpdate=!0},handlePointParents(){let e;for(const[t,i]of this.points){const n=t.object3D;i.copy(n.position),e=!1,n.traverseAncestors((t=>{t===this.el.object3D&&(e=!0),e||i.applyMatrix4(t.matrix)}))}},tick(){if(this.needsUpdate&&(this.needsUpdate=!1,this.points=new Map(Array.from(this.el.querySelectorAll("a-curve-point")).filter((e=>!!e.object3D)).map((e=>[e,new THREE.Vector3]))),this.handlePointParents(),!(this.points.size<=1))){this.curve=new THREE.CatmullRomCurve3(Array.from(this.points.values())),this.curve.closed=this.data.closed,this.curve.tension=this.data.tension,this.curve.arcLengthDivisions=Math.ceil(this.curve.getLength()/.01),this.curve.updateArcLengths(),this.ready=!0,this.el.emit("curve-updated");for(const[{object3D:i},n]of this.points){const{tangent:s,position:o}=this.closestPointInLocalSpace(n),r=s.multiplyScalar(.4).add(o),c=t.copy(r);d(o,e.set(0,1,0).applyQuaternion(i.quaternion),r,c),i.lookAt(c)}}},remove(){this.curve=null,this.ready=!1,this.observer.disconnect()},closestPointInLocalSpace(t,o){const r=this;if(!this.ready)throw Error("Curve not instantiated yet.");o=o||.1/this.curve.getLength();const c=[];for(let e=0;e<=20;e++){const i=e/20%1,s=this.curve.getPointAt(i,n),o=t.distanceTo(s);c.push(o)}const a=c.reduce(((e,t)=>e<t?e:t));return function c(a,h){const d=(1+a+h)%1,l=(1+a-h)%1,p=r.curve.getPointAt(d,n),v=r.curve.getPointAt(l,s),m=p.distanceTo(t),f=v.distanceTo(t),E=m<f;if(h<o){const t=r.curve.getTangentAt(E?d:l,i);if(h<o)return{result:E?d:l,position:E?p:v,distance:E?m:f,normal:u(t,e),tangent:t}}return c(m<f?d:l,h/2)}(c.indexOf(a)/20,.05)}}),AFRAME.registerComponent("curve-point",{description:"A point that tracks itself in 3D world space and updates the curve that it has changed.",dependencies:["position"],schema:{},init:function(){let e=this.el;for(;e&&e.matches&&!e.matches("a-curve,[curve]");)e=e.parentNode;if(!e)throw Error("curve-points need to be inside a curve");this.parentCurve=e,this.oldPos=new THREE.Vector3},update:function(){this.el.emit("point-change")},tick(){const e=this.el.object3D.getWorldPosition(n);0!==this.oldPos.manhattanDistanceTo(e)&&this.el.emit("point-shift"),this.oldPos.copy(e)},remove:function(){this.el.emit("point-change")}});const h=new THREE.Quaternion;function u(e,t){t.set(0,1,0);const i=t;return h.setFromUnitVectors(a,e),i.applyQuaternion(h),i}function d(e,t,i,n){const s=(t.dot(e)-t.dot(i))/t.length();return n.copy(t),n.multiplyScalar(s),n.add(i),n}AFRAME.registerComponent("draw-curve",{dependencies:["curve","material"],schema:{curve:{description:"Curve to draw, defaults to the curve on the same entity.",type:"selector"},spacing:{description:"How far apart to place the line segments, smaller is a smoother curve.",default:.5},tangent:{description:"Draw curve tangents",default:!1},normal:{description:"Draw curve normals",default:!1},length:{description:"Length to draw the normal and tangent markers",default:.1}},init:function(){this.el.addEventListener("curve-updated",this.update.bind(this))},update:function(){if(this.data.curve?this.curve=this.data.curve.components.curve:this.el.components.curve.curve&&(this.curve=this.el.components.curve),this.curve&&this.curve.curve){const t=this.curve.curve.getLength(),n=Math.ceil(t/this.data.spacing);let s,o,r;const c=new THREE.Line(new THREE.BufferGeometry,new THREE.LineBasicMaterial({color:"red"}));this.el.setObject3D("line",c);const a=this.curve.curve.getSpacedPoints(n);c.geometry.setFromPoints(a),this.data.tangent&&a.forEach(((t,r)=>{const a=r/n;s=e,s.copy(t),s.add(this.curve.curve.getTangentAt(a,i).normalize().multiplyScalar(this.data.length)),o=(new THREE.BufferGeometry).setFromPoints([t,s]),c.add(new THREE.Line(o,new THREE.LineBasicMaterial({color:"green"})))})),this.data.normal&&a.forEach(((t,o)=>{const a=o/n;s=u(this.curve.curve.getTangentAt(a,i),e).multiplyScalar(this.data.length),s.add(t),r=(new THREE.BufferGeometry).setFromPoints([t,s]),c.add(new THREE.Line(r,new THREE.LineBasicMaterial({color:"white"})))}))}},remove:function(){this.el.getObject3D("mesh").geometry=new THREE.Geometry}}),AFRAME.registerComponent("clone-along-curve",{description:"Apply this to the curve element, or set one seperately, to instance element at fixed intervals along a curve. They will be rotated to follw the curve.",dependencies:["curve"],schema:{curve:{description:"Optional, pick a particular curve to use, it defaults to the curve on it's own element",type:"selector"},spacing:{description:"How far apart to place the elements",default:1},scale:{description:"Scale of the elements",type:"vec3",default:{x:1,y:1,z:1}}},init:function(){this.onPointShift=this.onPointShift.bind(this),this.update=this.update.bind(this),this.el.addEventListener("model-loaded",function(e){e.target===this.el&&this.update()}.bind(this)),this.pointShift=!0},update:function(){this.remove(),this.data.curve?(this.curveEl=this.data.curve,this.curve=this.data.curve.components.curve,this.curveEl.addEventListener("curve-shift",this.onPointShift),this.curveEl.addEventListener("curve-updated",this.update)):this.el.components.curve&&(this.curveEl=this.el,this.curve=this.el.components.curve,this.curveEl.addEventListener("curve-shift",this.onPointShift),this.curveEl.addEventListener("curve-updated",this.update))},onPointShift:function(){this.pointShift=!0;const e=this.el.getObject3D("clones");if(e){const t=e.children[0].instanceMatrix.count,i=this.curve.curve.getLength();Math.ceil(i/this.data.spacing)>Math.floor(1.05*t)&&this.update()}},tick(){const e=this.el.getObject3D("mesh");if(e){let t=this.el.getObject3D("clones");const s=this.curve.curve.getLength(),h=Math.ceil(s/this.data.spacing);if(!t&&this.curve&&(e.visible=!1,t=new THREE.Group,this.el.setObject3D("clones",t),e.traverse((function(e){if(e.geometry){const i=e.geometry.clone();i.applyMatrix4(e.matrix);const n=new THREE.InstancedMesh(i,e.material,h);n.instanceMatrix.setUsage(THREE.DynamicDrawUsage),t.add(n)}})),this.pointShift=!0),this.pointShift){const e=t.children[0].instanceMatrix.count;for(let s=0;s<e;s++)if(s>h){o.compose(c,r,c);for(const e of t.children)e.setMatrixAt(s,o)}else{const c=s/Math.min(h,e),u=this.curve.curve.getTangentAt(c,i);o.compose(this.curve.curve.getPointAt(c,n),r.setFromUnitVectors(a,u),this.data.scale);for(const e of t.children)e.setMatrixAt(s,o)}for(const e of t.children)e.instanceMatrix.needsUpdate=!0}}},remove:function(){this.curve=null;const e=this.el.getObject3D("clones");e&&(e.children.forEach((e=>e.dispose())),this.el.removeObject3D("clones"))}}),AFRAME.registerPrimitive("a-curve",{description:"Describes a curve doesn't display anything unless one of the other components is used",defaultComponents:{curve:{}},mappings:{closed:"curve.closed",tension:"curve.tension"}}),AFRAME.registerPrimitive("a-curve-point",{description:"This is used to set the control points of the curve, they don't need to be immediate children.",defaultComponents:{"curve-point":{}}}),AFRAME.registerPrimitive("a-draw-curve",{description:"Describes a curve this uses the draw-curve component to draw a line where the curve is.",defaultComponents:{"draw-curve":{},curve:{}},mappings:{curve:"draw-curve.curve",closed:"curve.closed",tension:"curve.tension"}})}()}();
//# sourceMappingURL=curve.min.js.map
